<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Отправки груза - ПТС</title>
  <script src="https://yastatic.net/s3/passport-sdk/autofill/v1/sdk-suggest-with-polyfills-latest.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    form {
      margin-bottom: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    form input, form textarea {
      padding: 8px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    form input[type="date"] {
      width: 130px;
    }
    form input[type="text"], form textarea {
      width: 180px;
    }
    form textarea {
      resize: vertical;
      height: 40px;
    }
    form button {
      padding: 8px 16px;
      font-size: 14px;
      cursor: pointer;
      background-color: #0078d7;
      color: white;
      border: none;
      border-radius: 4px;
      align-self: center;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 20px;
    }
    table, th, td {
      border: 1px solid #999;
    }
    th, td {
      padding: 8px;
      text-align: left;
      font-size: 14px;
    }
    th {
      background-color: #f0f0f0;
    }
    button.sync-btn {
      padding: 10px 20px;
      font-size: 15px;
      background-color: #28a745;
      border: none;
      border-radius: 5px;
      color: white;
      cursor: pointer;
    }
    button.sync-btn:hover {
      background-color: #218838;
    }
    /* Стили для кнопок Яндекс */
    .yandex-btn {
      background-color: #fc0;
      color: #000;
      padding: 10px 20px;
      font-size: 15px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .yandex-btn:hover {
      background-color: #f2c200;
    }
    .yandex-icon {
      width: 20px;
      height: 20px;
    }
    #syncStatus {
      margin-left: 10px;
      font-size: 14px;
    }
  </style>
</head>
<body>

  <h2>Добавить отправку груза</h2>
  <form id="recordForm" onsubmit="event.preventDefault(); addRecord();">
    <input id="fromCity" placeholder="Откуда (город)" required />
    <input id="fromDate" type="date" required />
    <input id="fromName" placeholder="Отправитель" />
    <input id="toCity" placeholder="Куда (город)" required />
    <input id="toDate" type="date" required />
    <input id="toName" placeholder="Получатель" />
    <input id="places" placeholder="Мест" />
    <textarea id="description" placeholder="Описание"></textarea>
    <button type="submit">Добавить</button>
  </form>

  <h2>Текущие отправки</h2>
  <table id="recordsTable">
    <thead>
      <tr>
        <th>Откуда</th>
        <th>Дата отгрузки</th>
        <th>Отправитель</th>
        <th>Куда</th>
        <th>Дата прибытия</th>
        <th>Получатель</th>
        <th>Мест</th>
        <th>Описание</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <div style="margin-top: 20px; display: flex; gap: 10px; align-items: center;">
    <button id="yandexAuthBtn" class="yandex-btn" onclick="handleYandexAuth()">
      <svg class="yandex-icon" viewBox="0 0 20 20" fill="none">
        <path d="M19.074 10c0 5.012-4.062 9.074-9.074 9.074S.926 15.012.926 10 4.988.926 10 .926 19.074 4.988 19.074 10z" fill="#FC3F1D"/>
        <path d="M8.801 14.627h1.33V5.373H8.098c-2.285 0-3.491 1.163-3.491 2.834 0 1.359.731 2.217 2.037 3.013l-2.436 3.407h1.523l2.153-3.117-.924-.654c-1.171-.827-1.687-1.37-1.687-2.6 0-.981.731-1.715 1.934-1.715h1.594v8.086z" fill="#fff"/>
      </svg>
      <span id="yandexBtnText">Подключить Яндекс</span>
    </button>
    <span id="syncStatus"></span>
  </div>

<script>
  // Загрузка из localStorage
  function loadRecords() {
    const data = localStorage.getItem('records');
    return data ? JSON.parse(data) : [];
  }

  // Сохранение в localStorage
  function saveRecords(records) {
    localStorage.setItem('records', JSON.stringify(records));
  }

  // Отрисовка таблицы
  function renderTable() {
    const tbody = document.querySelector("#recordsTable tbody");
    const records = loadRecords();

    tbody.innerHTML = "";
    records.forEach(rec => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${rec.fromCity}</td>
        <td>${rec.fromDate}</td>
        <td>${rec.fromName || ""}</td>
        <td>${rec.toCity}</td>
        <td>${rec.toDate}</td>
        <td>${rec.toName || ""}</td>
        <td>${rec.places || ""}</td>
        <td>${rec.description || ""}</td>
      `;
      tbody.appendChild(tr);
    });
  }

  // Добавление записи с уникальным id и updatedAt
  function addRecord() {
    const entry = {
      fromCity: document.getElementById("fromCity").value.trim(),
      fromDate: document.getElementById("fromDate").value,
      fromName: document.getElementById("fromName").value.trim(),
      toCity: document.getElementById("toCity").value.trim(),
      toDate: document.getElementById("toDate").value,
      toName: document.getElementById("toName").value.trim(),
      places: document.getElementById("places").value.trim(),
      description: document.getElementById("description").value.trim(),
      id: Date.now().toString() + Math.random().toString(16).slice(2),
      updatedAt: new Date().toISOString()
    };

    if (!entry.fromCity || !entry.toCity || !entry.fromDate || !entry.toDate) {
      alert("Поля 'Откуда', 'Куда' и даты обязательны");
      return;
    }

    const records = loadRecords();
    records.push(entry);
    saveRecords(records);
    renderTable();

    document.getElementById("recordForm").reset();
  }

  // Слияние записей по id с учётом updatedAt
  function mergeRecords(localRecords, yandexRecords) {
    const mergedMap = new Map();

    yandexRecords.forEach(rec => {
      mergedMap.set(rec.id, rec);
    });

    localRecords.forEach(localRec => {
      const existing = mergedMap.get(localRec.id);
      if (!existing) {
        mergedMap.set(localRec.id, localRec);
      } else {
        if (new Date(localRec.updatedAt) > new Date(existing.updatedAt)) {
          mergedMap.set(localRec.id, localRec);
        }
      }
    });

    return Array.from(mergedMap.values());
  }

  // Конфигурация Яндекс OAuth
  const YANDEX_CLIENT_ID = 'a230480e4e854dbbadc04456c1172f7e';
  let yandexToken = localStorage.getItem('yandexToken');
  const REDIRECT_URI = encodeURIComponent(window.location.origin + window.location.pathname);

  // Функция для проверки валидности токена
  async function checkTokenValidity() {
    if (!yandexToken) return false;
    
    try {
      const response = await fetch('https://cloud-api.yandex.net/v1/disk', {
        headers: {
          'Authorization': `OAuth ${yandexToken}`
        }
      });
      return response.ok;
    } catch (error) {
      console.error('Token validation error:', error);
      return false;
    }
  }

  // Функция для очистки токена
  function clearToken() {
    yandexToken = null;
    localStorage.removeItem('yandexToken');
    updateYandexButton();
  }

  // Обновленная функция проверки авторизации
  async function checkAuthResponse() {
    const hash = window.location.hash;
    
    if (hash && hash.includes('access_token')) {
      const params = new URLSearchParams(hash.substring(1));
      const token = params.get('access_token');
      
      if (token) {
        yandexToken = token;
        localStorage.setItem('yandexToken', token);
        window.location.hash = '';
        updateYandexButton();
        
        // Проверяем валидность полученного токена
        const isValid = await checkTokenValidity();
        if (!isValid) {
          clearToken();
          return false;
        }
        return true;
      }
    }
    return false;
  }

  // Обновленная функция авторизации
  function handleYandexAuth() {
    if (yandexToken) {
      syncWithYandex();
    } else {
      const width = 800;
      const height = 600;
      const left = (window.screen.width / 2) - (width / 2);
      const top = (window.screen.height / 2) - (height / 2);
      
      const authUrl = 'https://oauth.yandex.ru/authorize?' + new URLSearchParams({
        'response_type': 'token',
        'client_id': YANDEX_CLIENT_ID,
        'redirect_uri': 'https://sv3t0v1k.github.io/cargo-tracker/',
        'force_confirm': 'true',
        'display': 'popup'
      }).toString();
      
      const authWindow = window.open(
        authUrl,
        'YandexAuth',
        `width=${width},height=${height},left=${left},top=${top}`
      );

      // Функция для проверки токена из popup окна
      const checkToken = async () => {
        try {
          if (authWindow.closed) {
            const token = prompt('Пожалуйста, скопируйте токен из открывшегося окна:');
            if (token) {
              yandexToken = token;
              localStorage.setItem('yandexToken', token);
              updateYandexButton();
              
              // Проверяем валидность полученного токена
              const isValid = await checkTokenValidity();
              if (!isValid) {
                clearToken();
                alert('Недействительный токен. Пожалуйста, попробуйте снова.');
              } else {
                syncWithYandex();
              }
            }
            return;
          }
          setTimeout(checkToken, 500);
        } catch (e) {
          setTimeout(checkToken, 500);
        }
      };

      checkToken();
    }
  }

  // Обновленная функция загрузки с Яндекс.Диска
  async function loadFromYandexDisk() {
    try {
      // Проверяем существование файла
      const checkFileResponse = await fetch('https://cloud-api.yandex.net/v1/disk/resources?path=/cargo.xlsx', {
        method: 'GET',
        headers: {
          'Authorization': `OAuth ${yandexToken}`
        }
      });

      if (checkFileResponse.status === 404) {
        return [];
      }

      if (!checkFileResponse.ok) {
        if (checkFileResponse.status === 401) {
          clearToken();
          throw new Error('Требуется повторная авторизация');
        }
        throw new Error('Ошибка проверки файла');
      }

      // Получаем ссылку на скачивание
      const downloadLinkResponse = await fetch('https://cloud-api.yandex.net/v1/disk/resources/download?path=/cargo.xlsx', {
        method: 'GET',
        headers: {
          'Authorization': `OAuth ${yandexToken}`
        }
      });

      if (!downloadLinkResponse.ok) {
        throw new Error('Не удалось получить ссылку на скачивание');
      }

      const { href } = await downloadLinkResponse.json();

      // Скачиваем файл
      const fileResponse = await fetch(href);
      if (!fileResponse.ok) {
        throw new Error('Не удалось скачать файл');
      }

      const arrayBuffer = await fileResponse.arrayBuffer();
      const data = new Uint8Array(arrayBuffer);
      const workbook = XLSX.read(data, { type: 'array' });
      
      if (!workbook.SheetNames.length) {
        throw new Error('Excel файл не содержит листов');
      }

      const worksheet = workbook.Sheets[workbook.SheetNames[0]];
      return XLSX.utils.sheet_to_json(worksheet, { raw: true });
    } catch (error) {
      console.error('Error loading from Yandex.Disk:', error);
      if (error.message.includes('авторизац')) {
        clearToken();
      }
      throw error;
    }
  }

  // Обновленная функция сохранения на Яндекс.Диск
  async function saveToYandexDisk(records) {
    try {
      // Создаем Excel файл
      const worksheet = XLSX.utils.json_to_sheet(records);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, 'Cargo');
      
      // Преобразуем в бинарный формат
      const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
      const blob = new Blob([excelBuffer], { 
        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
      });

      // Получаем URL для загрузки
      const uploadUrlResponse = await fetch('https://cloud-api.yandex.net/v1/disk/resources/upload?' + new URLSearchParams({
        path: '/cargo.xlsx',
        overwrite: 'true'
      }), {
        method: 'GET',
        headers: {
          'Authorization': `OAuth ${yandexToken}`
        }
      });

      if (!uploadUrlResponse.ok) {
        if (uploadUrlResponse.status === 401) {
          clearToken();
          throw new Error('Требуется повторная авторизация');
        }
        throw new Error('Не удалось получить URL для загрузки');
      }

      const { href: uploadUrl } = await uploadUrlResponse.json();

      // Загружаем файл
      const uploadResponse = await fetch(uploadUrl, {
        method: 'PUT',
        body: blob,
        headers: {
          'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        }
      });

      if (!uploadResponse.ok) {
        throw new Error('Не удалось загрузить файл');
      }

      return true;
    } catch (error) {
      console.error('Error saving to Yandex.Disk:', error);
      if (error.message.includes('авторизац')) {
        clearToken();
      }
      throw error;
    }
  }

  // Обновленная функция синхронизации
  async function syncWithYandex() {
    const statusEl = document.getElementById('syncStatus');
    statusEl.textContent = 'Проверка авторизации...';

    try {
      // Проверяем валидность токена
      const isValid = await checkTokenValidity();
      if (!isValid) {
        clearToken();
        throw new Error('Требуется авторизация');
      }

      statusEl.textContent = 'Синхронизация...';
      
      const localRecords = loadRecords();
      const yandexRecords = await loadFromYandexDisk();
      const mergedRecords = mergeRecords(localRecords, yandexRecords);
      
      await saveToYandexDisk(mergedRecords);
      saveRecords(mergedRecords);
      renderTable();

      statusEl.textContent = 'Синхронизация завершена';
      setTimeout(() => {
        statusEl.textContent = '';
      }, 3000);
    } catch (error) {
      console.error('Sync error:', error);
      statusEl.textContent = error.message;
      setTimeout(() => {
        statusEl.textContent = '';
      }, 3000);
    }
  }

  // Обновленная функция обновления состояния кнопки
  function updateYandexButton() {
    const btn = document.getElementById('yandexBtnText');
    btn.textContent = yandexToken ? 'Синхронизировать' : 'Подключить Яндекс';
  }

  // Инициализация при загрузке страницы
  window.addEventListener('load', async function() {
    if (yandexToken) {
      // Проверяем сохраненный токен
      const isValid = await checkTokenValidity();
      if (!isValid) {
        clearToken();
      }
    }
    updateYandexButton();
    renderTable();
  });
</script>

</body>
</html>
